# -*- coding: utf-8 -*-
"""10319002_practical01_AS2112_2020_NLE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iwCpxX8O7PIHcHuxUIToHpwlVvnymNlD

# PRAKTIKUM - 1 AS2112 Astronomi Komputasi

***Selasa, 15 September 2020***

Bisma Ridho Pambudi

NIM: 10319002

---

## Solusi Numerik Persamaan Tak-linear: Perhitungan Vernal atau Autumnal Equinox

Persamaan yang dapat memodelkan perubahan deklinasi Matahari dalam setahun (diukur dari ekuator langit) adalah

$$
\delta(\beta) = \frac{180}{\pi} \left\{ 0.006918 + 0.070257 \sin \beta + 0.000907 \sin (2\beta) + 0.00148 \sin (3\beta) - 0.399912 \cos \beta - 0.006758 \cos (2\beta) - 0.002697 \cos (3\beta) \right\}
$$

dimana

$$
\beta = \frac{2\pi J}{365}
$$

adalah *sudut tahun* (*year angle*) dan $J$ adalah *nomor hari* dalam satu tahun Gregorian (normal/kabisat) yang biasa digunakan saat ini. $J=0$ untuk 1 Januari dan berakhir di $J=364$ atau $J=365$. Akan tetapi perlu dicatat bahwa nilai $J$ ini **tidak harus bernilai bilangan bulat**. Gambar di bawah ini adalah kurva yang menjelaskan **persamaan untuk $\delta$ sebagai fungsi dari $J$**.

![deklinasi Matahari setahun](https://drive.google.com/uc?export=view&id=1EXJG8tT5xYyFhFmx7kSpumR3OWCZaVlE)

### PENJELASAN TUGAS

1. *Buatlah salinan/backup dari file ini. File yang Anda terima ini **adalah juga template file laporan praktikum** yang dapat Anda sunting sesuai dengan kebutuhan praktikum.*
2. *Meskipun praktikum dilakukan secara daring, Anda diminta membiasakan diri untuk tetap menjunjung tinggi integritas akademik dan memperhatikan Hak atas Kekayaan Intelektual (HaKI), termasuk dalam mengutip sumber-sumber. File notebook ini saya beri label [copyleft](https://en.wikipedia.org/wiki/Copyleft), sehingga, dalam perspektif hukum, Anda punya sejumlah keleluasaan. Tentang prinsip kebebasan untuk copyleft, silakan baca secara cepat tautan tersebut di Wikipedia.*
3. *Kode python di bawah naskah ini masih diperuntukkan bagi metode bisection. Anda dapat mencoba dulu dengan metode bisection ini secara cepat (hanya dengan mengganti definisi fungsi dan memilih $x_l$ dan $x_u$ yang sesuai) untuk mencari solusi $\delta = 0$. Saat nilai $\delta=0$, Matahari berada pada titik potong lingkaran ekuator dan ekliptika. Saat inilah yang disebut sebagai equinox (Latin, semakna dengan equal night), sehingga panjang siang dan malam di sekitar tanggal tersebut dirasakan sama.*
4. *Dengan menggunakan metode **Newton-Raphson**, carilah solusi dari $\delta = 0$ berupa bilangan-bilangan riil untuk nilai $\beta$ dan $J$. Metode ini mungkin berhasil, mungkin pula gagal diterapkan. Tetapi yang dinilai adalah menunjukkan keberhasilan atau kegagalan metode Newton-Raphson ini dengan kode python yang benar/baik. Selain itu, Anda sudah punya referensi solusi dengan metode lain yang sudah Anda lakukan, yaitu metode bisection (bagi dua).*
"""

'''
silakan sunting, termasuk ubah nama,
(copyleft) 2020, Muhamad Irfan Hakim, Numerical solution of non-linear equation using bisection method
'''

# for some function call, we need math module
from math import *

def f(x):
    '''
    A non-linear function
    '''
    return 180 * (0.006918 + 0.070257 * sin(x) + 0.000907 * sin(2*x) \
                  + 0.00148 * sin(3*x) - 0.399912 * cos(x) \
                  - 0.006758 * cos(2*x) - 0.002697 * cos(3*x))/pi

# tanda "#" sebagai awal baris-baris komentar di blok ini mungkin perlu dihapus
# jika metode yang digunakan adalah Newton-Raphson

#def df(x):
#   '''
#   First derivative of the function
#   '''
#   return 180 * (0.070257 * cos(x) + 2 * 0.000907 * cos(2*x) \
#                 + 3 * 0.00148 * cos(3*x) + 0.399912 * sin(x) \
#                 + 2 * 0.006758 * sin(2*x) + 3 * 0.002697 * sin(3*x))/pi

# for very first implementation attempt, it is recommended that input values are
# written down in the code, in this program: absolute value of relative
# approximate error, maximum iterations, xlower, and xupper
# the first two values are needed to control computation flow and may need to
# adjust

epsTol  = 1E-10
iterMax = 1000

#################################
# HERE COMES THE BISECTION METHOD
#################################
xl = 0.0
xu = 2.0

yl = f(xl)
yu = f(xu)

# CHECK IT. Is it TRUE?

yl*yu < 0

# initial value of epsloop = 1E+6 is just a trick to make sure that computation
# will proceed, but actually we don't have it

xm      = 0.5*(xl + xu)
iter    = 1
epsloop = 1E+6

# table preparation and first calculation
# "\t" is for tab
# ".8f", "+.8f", and ".6E" are numerical format specifiers

print(f'-----------------------------------------------------------')
print(f'iteration\txm\t\teps\t\tf(xm)')
print(f'-----------------------------------------------------------')
print(f'{iter}\t\t{xm:.8f}\t--\t\t{f(xm):+.8f}')

# we are IN LOOP ONLY IF BOTH "epsloop > epsTol" AND "iter < iterMax" ARE TRUE
#
#   >> QUIT from the loop if epsloop > epsTol == FALSE, which is epsloop less
#                                                       than or equal epsTol, or
#   >> QUIT from the loop if iter < iterMax == FALSE, which is iter greater than
#                                                     or equal iterMax

# try to change "and" with "or"
while epsloop > epsTol and iter < iterMax:
    xm0  = xm
    iter = iter + 1

    if (f(xl) * f(xm) < 0):
        xu = xm
    elif (f(xl) * f(xm) > 0):
        xl = xm
    elif ((f(xl) * f(xm) == 0) or (f(xl) * f(xm) < epsTol)):
        break

    xm      = 0.5*(xl + xu)
    epsloop = 100*abs((xm - xm0)/xm)

    print(f'{iter}\t\t{xm:.8f}\t{epsloop:.6E}\t{f(xm):+.8f}')

print(f'-----------------------------------------------------------')
print(f'iteration\txm\t\teps\t\tf(xm)')
print(f'-----------------------------------------------------------')
J = 0.5*365*xm/pi
print(f'SOLUTION: J = {J:.8f}, while J = 0 is January 1')
print('DONE.')